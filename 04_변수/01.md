
# 변수
→ variable

→ 하나의 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름

→ CPU: 연산 / 메모리: 데이터 기억

→ 값의 위치를 가리키는 상징적인 이름

→ 메모리 주소를 통해 값을 저장하고 참조할 필요 X (안전하게 접근)

→ 변수명: 변수이름

→ 변수 값: 변수에 저장한 값

→ 할당(assignment): 변수에 값을 저장하는 것(대입, 저장)

→ 참조(reference): 변수에 저장된 값을 읽어 들이는 것

→ 변수 이름을 통해 값의 의미를 알 수 있도록 가독성 좋게 만들어야 함

## 식별자
→ 어떤 값을 구별해서 식별할 수 있는 고유한 이름

→ 값 기억 X / 메모리 주소 기억

→ 메모리 주소에 붙인 이름

→ 변수, 함수, 클래스 등의 이름

→ 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름

→ 네이밍 규칙 준수

→ 선언(declaration)에 의해 자바스크립트 엔진에 식별자 존재 알림

## 변수 선언
→ 변수 생성: variable declaration

→ 값을 저장하기 위한 메모리 공간 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장

→ var, let, const 키워드 사용

### var
→ ES6 이전, 변수를 선언할 수 있는 유일한 키워드

→ 블록 레벨 스코프 지원 X (함수 레벨 스코프 지원)

### keyword
→ 자바스크립트 코를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어

→ 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작 수행

### 변수 선언문
```javascript
  var score; // 변수 선언문 
```
→ 변수 선언한 이후, 변수값 할당X

→ 변수 선언에 의해 확보된 메모리 공간은 비어 있지 않음

→ 확보된 메모리 공간에 자바스크립트 엔진에 의해 **undefined 값이 암묵적**으로 할당되어 초기화 

→ 자바스크립트 엔진은 변수 선언을 2단계 거쳐 수행
 1. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재 알림
 2. 초기화 단계: 값을 저장하기 위한 메모리 공간 확보하고 암묵적으로 undefined을 할당해 초기화 

→ 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록

→ 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을수있음 (garbage value) 

→ 자바스크립트에서는 암묵적으로 초기화 수행하므로 garbage value로부터 안전

→ 선언하지 않은 값을 접근할 경우 ReferenceError(참조에러) 발생
### 실행 컨텍스트
→ 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역

→ 자바스크립트엔진은 실행 컨텍스트를 통해 식별자와 스코프 관리

→ 변수 이름과 변수 값은 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리

### 변수 호이스팅

→ 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

→ 변수 선언 런타임 전에 먼저 실행

→ 모든 선언문(변수 선언문, 함수 선언문 등) 먼저 실행 후 선언문을 제외한 소스 코드 순차적 실행

→ var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등) 호이스팅 현상 생김

[참고링크: let, const 호이스팅?](https://yceffort.kr/2020/05/var-let-const-hoisting)

### 값 할당
```javascript
// 선언과 할당
var age; // 변수 선언
age = 28; // 값의 할당

// 선언 할당 단축
var age = 28;
// 단축표현해도 선언과 할당 2개의 문으로 나우어서 각각 실행 (선언과 할당 실행 시점 다름)
```
→ 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행

→ 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행


### 상수

→ 값을 재할당할 수 없어서 변수에 저장된 값을 변경 불가

→ 단 한번만 할당할 수 있는 변수

### 가비지 콜렉터 (garbage collector)

→ 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능

→ 어떤 식별자도 참조하지 않는 메모리 공간 의미

→ 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수 방지

## 메모리 관리방식
→ 언매니지드 언어 vs 매니지드 언어
### 언매니지드 언어
→ c언어

→ malloc(), free(): 메모리 제어 기능 제공

→ 개발자가 주도: 개발자의 역량에 따라 최적의 성능 확보, 반대로 치명적 오류 생산 가능성 있음

### 매니지드 언어
→ 개발자가 명시적으로 메모리 할당하고 해제 불가

→ 더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터 수행

→ 일정한 생산성 확보, 성능 어느정도 손실 감수 

### 식별자 네이밍 규칙
→ 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($) 포함

→ 숫자 시작 불가

→ 특수문자 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)로 시작 가능

→ 예약어 사용불가

→ 유니코드 허용 (ES5): 한글 일본어 사용 가능하지만 권장X

→ 대소문자 구별

→ 변수 존재 목적을 쉽게 이해할 수 있도록 의미 표현


### 네이밍 컨벤션

→ 카멜 케이스 (camelCase)

→ 스네이크 케이스 (snake_case)

→ 파스칼 케이스 (PascalCase)

→ 헝가리언 케이스 (typeHungarianCase)

``` javascript
var strFirstName;
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```
### 식별자

→ 프로그래밍 언어에서 사용되고 있거나 사용될 예정 단어



### Vocabulary
→ 리터럴(literal)

→ 연산자(operator)

→ 표현식(expression)

→ 평가(evaluation)

→ 파싱(parsing)

→ 피연산자(operand)
